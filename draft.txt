暂时想到的一些东西，杂乱记录中……


整个类为一个泛型，以针对不同对象。
传入的带匹配项(data)应该是一个具有枚举器的容器，内部元素可以为任意类型。
传入的匹配内容(pattern)应该是一个字符串，类似于基本的正则表达式。使用“/”加上一个变量名格式的字符串来表示特定的类实例。
还需传入一个对象到表达字符串之间的等价函数。

借鉴C#的正则，但在语法上略有出入。主要是正则表达式无需再考虑元字符转义等问题（匹配的是类的实例，在表达式中自行定义等价函数，用变量名格式的字符串去表达即可），因此可以简化语法。



基本运算符：|、?、+、*、^、-、(、)、[、]、{、}、<、>、'。
普通对象不需要元字符，因此无需用到转义符“\”。
保留字符：@、\，任何情况下都不应该出现在输入中，程序内部有特殊用途。

匹配对象：/word/word
可以使用/{...}这种JSON表示方法，如果全部使用这种则无需传入对象到表达字符串之间的等价函数，而直接使用自定义类里面的相等判断。

匹配任意对象：.
匹配起始位置：^
匹配结束位置：$
匹配任意一个列举的对象：[/word]、[/word-[/word]]、[[/word]-[/word]]
匹配任意一个未列举的对象：[^/word]

命名捕获组（Capture Group）：(?'name'expression)
反向引用：(?=name)
不使用未命名的捕获组，所以也没有非捕获组。

量词（Quantifier）：{m}、{m,n}、{m,}、?、*、+
忽略优先，非贪婪匹配：{m}?、{m,n}?、{m,}?、??、*?、+?

分支结构（Alternation）：expression|expression

环视（Look Around）：逆序肯定环视(?<=expression)、逆序否定环视(?<!expression)、顺序肯定环视(?>=expression)、顺序否定环视(?>!expression)

狭义平衡组：(?'close-open'expression)
判断捕获组是否存在：(??name)
条件判断结构：((??name)yes|no)
固化分组：(?*expression)



可选功能：
对^和$进行优化（从后往前匹配？是否可以转化成从前往后匹配？后向引用需要特殊处理？）；need more test
计算需要匹配一个表达式的最小对象数目；done!
替换时的正则委托功能；done!
POSIX匹配模式（与条件判断结构冲突！！），反向匹配模式（与条件判断结构冲突！！）。
忽略所有空白符，支持注释：(?#)


问题：传入的对象数组中存在NULL如何处理？（目前未考虑，假设没有NULL）